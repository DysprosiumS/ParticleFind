import cv2
import csv
import argparse
import logging
import time
from pathlib import Path
from ultralytics import YOLO
from config import Config

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('detection.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class Config:
    """Конфигурация детектора кругов"""

    def __init__(self):
        # Пути
        self.video_path = 'D:/Docs/код частицы/example.mp4'
        self.model_path = 'yolov8n.pt'
        self.csv_filename = 'circles_coordinates.csv'
        self.output_video_path = 'output_with_detections.avi'

        # Параметры детекции
        self.confidence_threshold = 0.2
        self.target_classes = ['sports ball']  # Можно добавить: ['sports ball', 'orange', etc.]

        # Настройки отображения и вывода
        self.show_display = True
        self.output_video = False
        self.overwrite_csv = False

class CircleDetector:
    def __init__(self, config):
        self.config = config
        self.cap = None
        self.model = None
        self.video_writer = None
        self.frame_count = 0
        self.total_detections = 0

    def setup_video_capture(self):
        """Инициализация захвата видео с проверкой доступности файла"""
        video_path = Path(self.config.video_path)
        if not video_path.exists():
            raise FileNotFoundError(f"Видеофайл не найден: {self.config.video_path}")

        self.cap = cv2.VideoCapture(self.config.video_path)
        if not self.cap.isOpened():
            raise ValueError(f"Не удалось открыть видеофайл: {self.config.video_path}")

        # Получение информации о видео
        self.fps = self.cap.get(cv2.CAP_PROP_FPS)
        self.width = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        self.height = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        self.total_frames = int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT))

        logger.info(f"Видео: {self.config.video_path}")
        logger.info(f"Разрешение: {self.width}x{self.height}, FPS: {self.fps:.1f}, Кадров: {self.total_frames}")

    def setup_model(self):
        """Загрузка модели YOLO с проверкой"""
        try:
            self.model = YOLO(self.config.model_path)
            logger.info(f"Модель загружена: {self.config.model_path}")

            # Проверка доступных классов
            if hasattr(self.model, 'names'):
                logger.info("Доступные классы в модели:")
                for class_id, class_name in self.model.names.items():
                    logger.info(f"  {class_id}: {class_name}")

        except Exception as e:
            raise RuntimeError(f"Ошибка загрузки модели: {e}")

    def setup_video_writer(self):
        """Настройка записи выходного видео"""
        if self.config.output_video:
            fourcc = cv2.VideoWriter_fourcc(*'XVID')
            output_path = self.config.output_video_path
            self.video_writer = cv2.VideoWriter(
                output_path, fourcc, self.fps, (self.width, self.height)
            )
            logger.info(f"Выходное видео будет сохранено как: {output_path}")

    def setup_csv_file(self):
        """Создание и настройка CSV файла с автоматическим переименованием"""
        csv_path = Path(self.config.csv_filename)

        # Если файл существует и не разрешена перезапись - создаем новое имя
        if csv_path.exists() and not self.config.overwrite_csv:
            base_name = csv_path.stem
            suffix = csv_path.suffix
            counter = 1

            while True:
                new_name = f"{base_name}_{counter:03d}{suffix}"
                new_path = csv_path.parent / new_name
                if not new_path.exists():
                    self.config.csv_filename = str(new_path)
                    logger.info(f"CSV файл уже существует. Создан новый: {new_name}")
                    break
                counter += 1

        # Создание файла
        with open(self.config.csv_filename, mode='w', newline='', encoding='utf-8') as file:
            writer = csv.writer(file)
            writer.writerow([
                'Frame', 'Time (ms)', 'X', 'Y', 'Width', 'Height',
                'Confidence', 'Class', 'Timestamp'
            ])
        logger.info(f"CSV файл создан: {self.config.csv_filename}")

    def draw_detection(self, frame, x, y, w, h, conf, class_name):
        """Отрисовка обнаруженных объектов на кадре"""
        # Прямоугольник вокруг объекта
        x1, y1 = int(x - w / 2), int(y - h / 2)
        x2, y2 = int(x + w / 2), int(y + h / 2)

        cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)

        # Текст с информацией
        label = f'{class_name} {conf:.2f}'
        label_size, baseline = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.6, 2)

        # Фон для текста
        cv2.rectangle(frame,
                      (x1, y1 - label_size[1] - 10),
                      (x1 + label_size[0], y1),
                      (0, 255, 0), -1)

        # Сам текст
        cv2.putText(frame, label,
                    (x1, y1 - 5),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 0), 2)

        # Центральная точка
        cv2.circle(frame, (int(x), int(y)), 3, (0, 0, 255), -1)

    def process_frame(self, frame):
        """Обработка одного кадра с оптимизацией для круглых объектов"""
        detections = []

        # Улучшенные параметры детекции для круглых объектов
        results = self.model(
            frame,
            conf=self.config.confidence_threshold,
            iou=self.config.iou_threshold,
            imgsz=self.config.img_size,
            augment=True,  # Аугментация для лучшего обнаружения
            verbose=False
        )

        for result in results:
            for box in result.boxes:
                cls = int(box.cls)
                conf = float(box.conf)
                x, y, w, h = box.xywh[0].tolist()
                class_name = result.names[cls]

                # Дополнительная фильтрация по форме (отношение сторон близко к 1)
                aspect_ratio = w / h
                is_circular = 0.7 <= aspect_ratio <= 1.3  # Объекты близкие к квадрату/кругу

                if class_name in self.config.target_classes and is_circular:
                    detection_data = {
                        'x': x, 'y': y, 'w': w, 'h': h,
                        'conf': conf, 'class_name': class_name,
                        'aspect_ratio': aspect_ratio
                    }
                    detections.append(detection_data)

                    # Запись в CSV
                    with open(self.config.csv_filename, mode='a', newline='', encoding='utf-8') as file:
                        writer = csv.writer(file)
                        writer.writerow([
                            self.frame_count,
                            self.cap.get(cv2.CAP_PROP_POS_MSEC),
                            x, y, w, h, conf, class_name,
                            time.strftime('%Y-%m-%d %H:%M:%S'),
                            aspect_ratio  # Добавляем отношение сторон
                        ])

        return detections

    def add_statistics(self, frame, detections, processing_time):
        """Добавление статистики на кадр"""
        fps = 1.0 / processing_time if processing_time > 0 else 0

        # Основная статистика
        stats = [
            f'Frame: {self.frame_count}/{self.total_frames}',
            f'FPS: {fps:.1f}',
            f'Detections: {len(detections)}',
            f'Total: {self.total_detections}'
        ]

        for i, stat in enumerate(stats):
            cv2.putText(frame, stat, (10, 30 + i * 25),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)

        # Прогресс-бар
        if self.total_frames > 0:
            progress = self.frame_count / self.total_frames
            bar_width = 400
            cv2.rectangle(frame, (10, 120), (10 + bar_width, 130), (100, 100, 100), -1)
            cv2.rectangle(frame, (10, 120), (10 + int(bar_width * progress), 130), (0, 255, 0), -1)

    def run(self):
        """Основной цикл обработки видео"""
        try:
            # Инициализация компонентов
            self.setup_video_capture()
            self.setup_model()
            self.setup_video_writer()
            self.setup_csv_file()

            logger.info("Начало обработки видео...")
            start_time = time.time()

            while True:
                frame_start_time = time.time()
                ret, frame = self.cap.read()

                if not ret:
                    break

                # Обработка кадра
                detections = self.process_frame(frame)
                self.total_detections += len(detections)

                # Визуализация
                for detection in detections:
                    self.draw_detection(
                        frame,
                        detection['x'], detection['y'],
                        detection['w'], detection['h'],
                        detection['conf'], detection['class_name']
                    )

                # Добавление статистики
                processing_time = time.time() - frame_start_time
                self.add_statistics(frame, detections, processing_time)

                # Отображение
                if self.config.show_display:
                    cv2.imshow('Circle Detection', frame)

                # Запись видео
                if self.video_writer is not None:
                    self.video_writer.write(frame)

                # Обработка клавиш
                key = cv2.waitKey(1) & 0xFF
                if key == ord('q'):
                    logger.info("Остановка по запросу пользователя")
                    break
                elif key == ord('p'):
                    cv2.waitKey(0)  # Пауза

                self.frame_count += 1

                # Логирование прогресса
                if self.frame_count % 100 == 0:
                    elapsed = time.time() - start_time
                    logger.info(f"Обработано кадров: {self.frame_count}/{self.total_frames} "
                                f"({self.frame_count / self.total_frames * 100:.1f}%)")

            # Завершение
            total_time = time.time() - start_time
            logger.info(f"Обработка завершена за {total_time:.2f} секунд")
            logger.info(f"Всего кадров: {self.frame_count}, обнаружений: {self.total_detections}")
            logger.info(f"Средняя скорость: {self.frame_count / total_time:.2f} FPS")
            logger.info(f"Данные сохранены в: {self.config.csv_filename}")

        except Exception as e:
            logger.error(f"Ошибка во время выполнения: {e}")
            raise
        finally:
            self.cleanup()

    def cleanup(self):
        """Освобождение ресурсов"""
        if self.cap is not None:
            self.cap.release()
        if self.video_writer is not None:
            self.video_writer.release()
        cv2.destroyAllWindows()
        logger.info("Ресурсы освобождены")


def parse_arguments():
    """Парсинг аргументов командной строки с оптимизацией для круглых объектов"""
    parser = argparse.ArgumentParser(description='Детекция кругов в видео с помощью YOLO')

    parser.add_argument('--video_path', default='D:/Docs/код частицы/example.mp4',
                        help='Путь к входному видеофайлу')
    parser.add_argument('--model_path', default='yolov8n.pt',
                        help='Путь к модели YOLO')
    parser.add_argument('--csv_filename', default='circles_coordinates.csv',
                        help='Имя выходного CSV файла')

    # КРИТИЧЕСКИЕ ПАРАМЕТРЫ ДЛЯ КРУГЛЫХ ОБЪЕКТОВ
    parser.add_argument('--confidence_threshold', type=float, default=0.3,  # Уменьшен порог
                        help='Порог уверенности для детекции')
    parser.add_argument('--iou_threshold', type=float, default=0.5,
                        help='IOU threshold для NMS')

    # Расширенный список классов для круглых объектов
    parser.add_argument('--target_classes', nargs='+',
                        default=['sports ball', 'orange', 'apple', 'donut', 'tennis racket'],
                        help='Классы для детекции')

    # Дополнительные параметры
    parser.add_argument('--img_size', type=int, default=3520,
                        help='Размер изображения для inference')

    parser.add_argument('--show_display', action='store_true', default=True)
    parser.add_argument('--output_video', action='store_true', default=False)
    parser.add_argument('--overwrite_csv', action='store_true', default=False)

    return parser.parse_args()


def main():
    """Основная функция"""
    try:
        # Парсинг аргументов
        config = parse_arguments()

        # Создание и запуск детектора
        detector = CircleDetector(config)
        detector.run()

    except KeyboardInterrupt:
        logger.info("Программа прервана пользователем")
    except Exception as e:
        logger.error(f"Критическая ошибка: {e}")
        return 1

    return 0

config = Config()
detector = CircleDetector(config)

if __name__ == "__main__":
    exit(main())